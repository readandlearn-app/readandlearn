---
phase: 01-production-infrastructure
plan: 02
type: execute
---

<objective>
Harden the backend and extension against common security vulnerabilities.

Purpose: Protect against abuse (rate limiting), injection attacks (input validation), and XSS (sanitization).
Output: Production-hardened codebase ready for public deployment.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md

**Depends on:** 01-01-PLAN.md (backend configuration complete)

**Relevant source files:**
@translation-backend/server.js
@extension/content.js

**From CONCERNS.md:**
- No rate limiting: API endpoints unprotected from abuse
- Missing input validation: User selections accepted without validation
- XSS vulnerability: Dynamic content insertion without sanitization (15+ locations in content.js)

**Security context:**
- Backend will be publicly accessible when deployed
- Extension injects content into arbitrary web pages
- User-selected text from pages is sent to backend
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rate limiting middleware</name>
  <files>translation-backend/server.js, translation-backend/package.json</files>
  <action>
    1. Install express-rate-limit: `npm install express-rate-limit`
    2. Add rate limiting configuration via environment variables:
       - RATE_LIMIT_WINDOW_MS (default: 60000 = 1 minute)
       - RATE_LIMIT_MAX_REQUESTS (default: 30 requests per window)
    3. Create rate limiter middleware after CORS middleware but before routes.
    4. Configure with standardHeaders: true, legacyHeaders: false.
    5. Return JSON error message when limit exceeded.
    6. Add RATE_LIMIT_* variables to .env.example with comments.

    Why 30 req/min default: Normal usage is ~5-10 requests per article analysis. 30 allows bursts while preventing abuse. Self-hosters can adjust via env vars.

    Avoid: Don't rate limit /health endpoint (breaks monitoring). Use skip option if needed.
  </action>
  <verify>
    1. Start server
    2. Make 31 rapid requests: the 31st should return 429 Too Many Requests
    3. Wait 1 minute, requests should work again
  </verify>
  <done>
    - express-rate-limit installed and configured
    - Rate limits configurable via environment variables
    - 429 response returned when limit exceeded
    - /health endpoint still accessible for monitoring
  </done>
</task>

<task type="auto">
  <name>Task 2: Add input validation middleware</name>
  <files>translation-backend/server.js</files>
  <action>
    1. Create validateAnalyzeRequest middleware for POST /analyze:
       - Check text field exists and is string
       - Check text length: min 10 chars, max 50000 chars (configurable via MAX_TEXT_LENGTH env var)
       - Check text contains actual words (not just whitespace/symbols)
       - Return 400 Bad Request with specific error message if validation fails
    2. Create validateDefineRequest middleware for POST /define:
       - Check word field exists and is string
       - Check word length: min 1 char, max 100 chars
       - Check word doesn't contain HTML tags or script content
       - Return 400 with specific error if validation fails
    3. Create validateDeckRequest middleware for POST /deck/add:
       - Validate word, translation, context fields
       - Check userId is present
       - Sanitize all string inputs (trim whitespace, remove null bytes)
    4. Apply middleware to respective routes.

    Why: Prevents oversized payloads, injection attempts, and malformed requests from reaching business logic. Early rejection saves resources.

    Avoid: Don't be too strict on text content (users read diverse content). Don't reject based on language detection here (that's business logic).
  </action>
  <verify>
    1. POST /analyze with empty text: should return 400
    2. POST /analyze with 100KB text: should return 400 "Text too long"
    3. POST /analyze with valid text: should work normally
    4. POST /define with HTML in word: should return 400
    5. POST /deck/add with missing fields: should return 400
  </verify>
  <done>
    - All API endpoints validate input before processing
    - Clear error messages for invalid requests
    - Configurable limits via environment variables
    - Existing valid requests still work
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix XSS vulnerabilities in extension</name>
  <files>extension/content.js</files>
  <action>
    **This task FIXES existing XSS vulnerabilities identified in CONCERNS.md.**

    1. Create a sanitizeForDisplay helper function that uses textContent assignment to escape HTML entities safely.

    2. Identify all locations where dynamic/external data is rendered:
       - API response data (translations, definitions)
       - Error messages that may contain user text
       - Highlighted text from page content

    3. For each location, apply the appropriate fix:
       - Use textContent instead of dynamic HTML insertion where possible
       - Use the sanitizeForDisplay helper for mixed content
       - Use DOMParser for complex HTML transformations (safer than string concatenation)

    4. For static template HTML (menus, buttons), no changes needed - these are safe.

    Why: Defense in depth - even "trusted" API responses could be compromised. This is a REMEDIATION of existing vulnerability.

    Avoid: Don't break existing highlight functionality. Don't add heavy dependencies.
  </action>
  <verify>
    1. Load extension on a test page
    2. Select text containing script tags or event handlers
    3. Get meaning - should display the text literally, not execute
    4. Add to deck - should store safely
    5. All existing functionality still works (analysis, questions, deck)
  </verify>
  <done>
    - Helper function added for safe content display
    - All dynamic content properly escaped before display
    - Malicious content displays as text, doesn't execute
    - Existing functionality unchanged
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Security hardening: rate limiting, input validation, XSS fixes</what-built>
  <how-to-verify>
    1. Start backend: `cd translation-backend && npm start`
    2. Load extension in Chrome (chrome://extensions, Load unpacked)

    **Rate limiting test:**
    3. Open terminal, run rapid requests to /health endpoint
    4. Confirm: First 30 return 200, remaining return 429

    **Input validation test:**
    5. POST to /analyze with empty text body
    6. Confirm: Returns 400 with error message

    **XSS fix test:**
    7. Open any article in browser with extension active
    8. Select text containing angle brackets and event handlers
    9. Click "Get Meaning" button
    10. Confirm: Text displays literally, no code execution

    **Functional test:**
    11. Analyze a real French article - should work normally
    12. Add a word to deck - should work normally
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm ls express-rate-limit` shows package installed
- [ ] Rate limiting returns 429 after limit exceeded
- [ ] Invalid input returns 400 with helpful message
- [ ] Malicious payloads display as text, don't execute
- [ ] Normal extension usage works without issues
- [ ] All security tests from checkpoint pass
</verification>

<success_criteria>
- All 4 tasks completed (3 auto + 1 checkpoint)
- Rate limiting protects all endpoints
- Input validation catches malformed requests
- XSS vulnerabilities remediated
- Human verification confirms security improvements
- Phase 1 complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-production-infrastructure/01-02-SUMMARY.md`

This completes Phase 1: Production Infrastructure. The codebase is now:
- Configurable (no hardcoded URLs)
- Secure (CORS restricted, rate limited, validated, XSS fixed)
- Production-ready (API key validation, clear error messages)
</output>
