---
phase: 01-production-infrastructure
plan: 01
type: execute
---

<objective>
Configure backend for production deployment with proper environment handling and security.

Purpose: Enable the backend to be deployed anywhere without hardcoded URLs or overly permissive CORS.
Output: Configurable backend that validates its API key at startup and restricts CORS to extension origins.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONCERNS.md

**Relevant source files:**
@extension/background.js
@extension/content.js
@extension/manifest.json
@translation-backend/server.js
@translation-backend/.env.example

**From CONCERNS.md:**
- Hardcoded `BACKEND_URL = 'http://localhost:3000'` in extension/background.js (line 1) and extension/content.js (line 34)
- Overly permissive CORS: `Access-Control-Allow-Origin: *` in server.js (line 13)
- No API key validation at startup (only discovered on first Claude call)

**Constraints:**
- Extension needs to work with any backend URL (local dev, self-hosted, cloud)
- CORS must allow Chrome extension origins (chrome-extension://*)
- API key validation should fail fast at startup, not on first user request
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make backend URL configurable in extension</name>
  <files>extension/background.js, extension/content.js, extension/manifest.json</files>
  <action>
    1. In background.js: Replace hardcoded BACKEND_URL with a function that reads from chrome.storage.sync, defaulting to 'http://localhost:3000' for development.
    2. In content.js: Remove the BACKEND_URL constant entirely - all API calls go through background.js message passing (which already exists).
    3. In manifest.json: Update host_permissions to include pattern for any host ("*://*/*") since backend URL is user-configurable. Add "storage" permission if not present.
    4. Create extension/options.html and extension/options.js for users to configure their backend URL (simple form with save button).
    5. Register options page in manifest.json.

    Why this approach: Chrome extensions can't read environment variables. chrome.storage.sync persists across browser sessions and syncs across devices. Options page is the standard pattern for user configuration.

    Avoid: Don't use localStorage (doesn't persist properly in MV3 service workers). Don't hardcode multiple URLs with a switch statement.
  </action>
  <verify>
    1. Load unpacked extension in Chrome
    2. Right-click extension icon â†’ Options
    3. Change backend URL to a test value
    4. Verify the setting persists after browser restart
    5. Check background.js console for the configured URL being used
  </verify>
  <done>
    - Extension reads backend URL from chrome.storage.sync
    - Options page allows users to configure backend URL
    - Default URL is localhost:3000 for development
    - No hardcoded URLs remain in extension code
  </done>
</task>

<task type="auto">
  <name>Task 2: Restrict CORS to Chrome extension origins</name>
  <files>translation-backend/server.js, translation-backend/.env.example</files>
  <action>
    1. Add ALLOWED_ORIGINS environment variable to .env.example with default value "chrome-extension://*".
    2. In server.js, replace the static `Access-Control-Allow-Origin: *` with dynamic origin validation:
       - Parse ALLOWED_ORIGINS as comma-separated list
       - Check if request origin matches any allowed pattern (support wildcards)
       - For chrome-extension://* pattern, match any chrome-extension:// origin
       - Include localhost origins for development: http://localhost:*, http://127.0.0.1:*
       - If origin matches, set Access-Control-Allow-Origin to the specific origin (not *)
       - If no match, don't set the header (browser will block)
    3. Keep Access-Control-Allow-Private-Network: true for local development.

    Why: CORS * allows any website to call the API. Restricting to chrome-extension:// ensures only the extension can make requests. Dynamic origin reflection is required because Access-Control-Allow-Credentials doesn't work with *.

    Avoid: Don't remove CORS entirely (breaks preflight). Don't use a fixed extension ID (changes per installation).
  </action>
  <verify>
    1. Start backend with default ALLOWED_ORIGINS
    2. Test from extension: should work
    3. Test from browser console on any website: `fetch('http://localhost:3000/health')` should fail with CORS error
    4. Test with curl (no origin): should work (curl doesn't send Origin header)
  </verify>
  <done>
    - CORS restricted to chrome-extension:// and localhost origins
    - ALLOWED_ORIGINS configurable via environment variable
    - Random websites cannot call the API
    - Extension still works normally
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate Claude API key at startup</name>
  <files>translation-backend/server.js</files>
  <action>
    1. Create async function validateApiKey() that makes a minimal Claude API call to verify the key works.
       - Use the messages API with max_tokens: 1 and a simple prompt
       - Return true if 200 response, false otherwise
       - Log clear error message if validation fails
    2. Call validateApiKey() during server startup (after database connection test).
    3. If validation fails:
       - Log error with instructions: "Invalid CLAUDE_API_KEY. Get your key from https://console.anthropic.com/"
       - Continue server startup (don't crash) but set a flag `apiKeyValid = false`
       - Return 503 Service Unavailable on endpoints that need Claude API, with message explaining the issue
    4. Update /health endpoint to include `apiKeyValid: true/false` in response.

    Why: Users often misconfigure API keys. Failing fast with a clear message saves debugging time. Not crashing allows health checks to still work for infrastructure monitoring.

    Avoid: Don't make a full analysis call for validation (expensive). Don't crash the server (breaks container health checks).
  </action>
  <verify>
    1. Start server with valid API key: should see "API key validated" log
    2. Start server with invalid API key: should see clear error message
    3. With invalid key, GET /health should return { apiKeyValid: false }
    4. With invalid key, POST /analyze should return 503 with helpful message
  </verify>
  <done>
    - API key validated at startup with clear success/failure logging
    - Health endpoint reports apiKeyValid status
    - Invalid key returns 503 on Claude-dependent endpoints
    - Server doesn't crash on invalid key
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] No hardcoded localhost:3000 URLs in extension/*.js files
- [ ] Extension options page exists and works
- [ ] CORS blocks requests from random websites
- [ ] /health endpoint shows apiKeyValid status
- [ ] Backend starts successfully with valid and invalid API keys
- [ ] `grep -r "localhost:3000" extension/` returns only manifest.json default
</verification>

<success_criteria>
- All 3 tasks completed
- Extension configurable without code changes
- CORS properly restricted
- API key validation provides clear feedback
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/01-production-infrastructure/01-01-SUMMARY.md`
</output>
