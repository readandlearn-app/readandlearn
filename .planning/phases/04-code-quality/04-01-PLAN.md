---
phase: 04-code-quality
plan: 01
type: execute
---

<objective>
Set up Vitest test framework for the backend and create initial test infrastructure.

Purpose: Establish testing foundation before modularization to catch regressions.
Output: Working Vitest configuration with first passing tests for utility functions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context:
@.planning/phases/01-production-infrastructure/01-02-SUMMARY.md

# Key files:
@translation-backend/package.json
@translation-backend/server.js

**Tech stack available:** express, express-rate-limit, pg, @xenova/transformers
**Established patterns:** Input validation middleware, sanitization helpers

**Constraining decisions:**
- Phase 01-02: Input validation middleware pattern established
- Phase 01-02: sanitizeForDisplay, validateAnalyzeRequest patterns exist
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Vitest and create configuration</name>
  <files>translation-backend/package.json, translation-backend/vitest.config.js</files>
  <action>
1. Install Vitest as dev dependency: `npm install -D vitest`
2. Create vitest.config.js with:
   - Environment: node
   - Test files: **/*.test.js
   - Coverage reporter (optional for now)
3. Add test script to package.json: "test": "vitest run"
4. Add test:watch script: "test:watch": "vitest"

Do NOT install additional dependencies (c8, coverage tools) - keep minimal.
  </action>
  <verify>npm test runs without errors (0 tests found is OK)</verify>
  <done>Vitest installed, config exists, npm test command works</done>
</task>

<task type="auto">
  <name>Task 2: Create first utility tests</name>
  <files>translation-backend/utils/validation.js, translation-backend/utils/validation.test.js</files>
  <action>
1. Extract these pure functions from server.js into utils/validation.js:
   - sanitizeString(str) - removes null bytes, trims, limits length
   - containsHtmlOrScript(str) - checks for HTML/script injection
   - isValidLanguage(code) - validates ISO 639-1 codes
   - getLanguageName(code) - returns language display name
   - Also export SUPPORTED_LANGUAGES constant

2. Create utils/validation.test.js with tests:
   - sanitizeString: handles null, empty, long strings, null bytes
   - containsHtmlOrScript: detects <script>, onclick=, javascript:
   - isValidLanguage: accepts 'fr', 'en', rejects 'xx', ''
   - getLanguageName: returns 'French' for 'fr', 'Unknown' for invalid

3. Update server.js to import from utils/validation.js

Pattern: Keep tests simple, one assertion per test when possible.
  </action>
  <verify>npm test passes with all validation tests green</verify>
  <done>utils/validation.js extracted, tests passing, server.js imports work</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm test` in translation-backend passes
- [ ] `npm start` still works (no import errors)
- [ ] At least 8 tests exist for validation utilities
</verification>

<success_criteria>
- Vitest installed and configured
- Validation utilities extracted to separate module
- Tests cover sanitization, HTML detection, language validation
- Server still starts and works normally
</success_criteria>

<output>
After completion, create `.planning/phases/04-code-quality/04-01-SUMMARY.md`:

# Phase 4 Plan 01: Test Framework Setup Summary

**[Substantive one-liner about what shipped]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- [Files with descriptions]

## Decisions Made
- [Any runtime decisions]

## Issues Encountered
- [Problems and resolutions]

## Next Step
- Ready for 04-02: Backend Modularization
</output>
