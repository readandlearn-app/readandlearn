---
phase: 04-code-quality
plan: 03
type: execute
---

<objective>
Modularize the Chrome extension content.js (2294 lines) into focused modules.

Purpose: Improve maintainability of the extension codebase.
Output: content.js as thin entry point, with logic in separate module files.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan context:
@.planning/phases/04-code-quality/04-02-SUMMARY.md

# Key files:
@extension/content.js
@extension/manifest.json

**Tech stack available:** Chrome Extension MV3, PDF.js
**Established patterns:**
- analyzeContent() dispatcher (03-02)
- chrome.storage.sync for config (01-01)
- chrome.i18n.detectLanguage() (02-02)

**Current content.js structure:**
- UI creation: R/L button, menu, banner
- API calls: analyze, define, deck operations
- PDF handling: isPdfContext, extractPdfText, analyzePdf
- Language: detectLanguage, getEffectiveLanguage, language selector
- Utilities: getBackendUrl, showBanner
</context>

<tasks>

<task type="auto">
  <name>Task 1: Split content.js into module files</name>
  <files>extension/modules/ui.js, extension/modules/api.js, extension/modules/pdf.js, extension/modules/language.js, extension/modules/utils.js</files>
  <action>
Create modules directory and split by concern:

1. modules/ui.js - UI creation and manipulation
   - createButton() - R/L button creation
   - createMenu() - side menu creation
   - showBanner() - notification banner
   - updateMenuContent() - populate menu with analysis
   - makeDraggable() - button drag handling
   - Export all UI functions

2. modules/api.js - Backend API interactions
   - getBackendUrl() - get configured URL
   - analyzeArticle() - send text to /analyze
   - defineWord() - send to /define
   - addToDeck() - POST to /deck/add
   - fetchDeck() - GET deck contents
   - Export all API functions

3. modules/pdf.js - PDF handling
   - isPdfContext() - detect PDF page
   - loadPdfJs() - lazy load PDF.js
   - extractPdfText() - extract text from PDF
   - analyzePdf() - PDF analysis flow
   - MAX_PDF_PAGES constant
   - Export all PDF functions

4. modules/language.js - Language detection and selection
   - detectLanguage() - chrome.i18n.detectLanguage wrapper
   - getEffectiveLanguage() - priority chain resolution
   - createLanguageSelector() - dropdown creation
   - getStoredLanguage(), setStoredLanguage()
   - SUPPORTED_LANGUAGES if needed client-side
   - Export all language functions

5. modules/utils.js - Shared utilities
   - sanitizeForDisplay() - XSS protection
   - getArticleText() - extract text from page
   - Any other small helpers
   - Export utilities

**Important:** Chrome extensions with MV3 use ES modules. Each file should:
- Use export for functions
- Use import for dependencies
- NOT use require() (CommonJS)
  </action>
  <verify>All module files exist and can be loaded in browser console</verify>
  <done>5 module files created with extracted functions</done>
</task>

<task type="auto">
  <name>Task 2: Update content.js as entry point and update manifest</name>
  <files>extension/content.js, extension/manifest.json</files>
  <action>
1. Update content.js to be thin entry point:
```javascript
// Import modules
import { createButton, createMenu, showBanner, updateMenuContent } from './modules/ui.js';
import { analyzeArticle, defineWord, addToDeck } from './modules/api.js';
import { isPdfContext, analyzePdf } from './modules/pdf.js';
import { detectLanguage, getEffectiveLanguage, createLanguageSelector } from './modules/language.js';
import { sanitizeForDisplay, getArticleText } from './modules/utils.js';

// Main initialization
function init() {
  const button = createButton();
  button.addEventListener('click', analyzeContent);
  document.body.appendChild(button);
}

function analyzeContent() {
  if (isPdfContext()) {
    analyzePdf();
  } else {
    analyzeArticle();
  }
}

// Initialize when DOM ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
```

2. Update manifest.json if needed:
   - Content scripts don't directly support ES modules in MV3
   - Option A: Keep as single file (simpler, no manifest change)
   - Option B: Use dynamic import() for lazy loading

   **Decision:** Use IIFE pattern with dynamic imports to maintain single entry point while enabling code splitting. This avoids manifest changes.

3. Refactor to use dynamic imports:
```javascript
// content.js - entry point
(async function() {
  const { createButton } = await import(chrome.runtime.getURL('modules/ui.js'));
  const { isPdfContext, analyzePdf } = await import(chrome.runtime.getURL('modules/pdf.js'));
  // ... etc

  // Initialize
  init();
})();
```

4. Update manifest.json web_accessible_resources to include modules:
```json
"web_accessible_resources": [
  {
    "resources": ["lib/pdf.min.mjs", "lib/pdf.worker.min.mjs", "modules/*.js"],
    "matches": ["<all_urls>"]
  }
]
```

Target: content.js under 100 lines as orchestration layer.
  </action>
  <verify>Extension loads without errors in Chrome, R/L button appears, article analysis works</verify>
  <done>content.js is <100 lines, all features work via extension testing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Extension loads in Chrome without errors
- [ ] R/L button appears on web pages
- [ ] Article analysis works end-to-end
- [ ] PDF analysis works
- [ ] Language detection works
- [ ] Deck operations work
- [ ] content.js is under 150 lines
</verification>

<success_criteria>
- content.js reduced from 2294 lines to <150 lines
- 5 module files with focused responsibilities
- All existing functionality preserved
- Extension works without errors
- Phase 4: Code Quality complete after this plan
</success_criteria>

<output>
After completion, create `.planning/phases/04-code-quality/04-03-SUMMARY.md`:

# Phase 4 Plan 03: Extension Modularization Summary

**[Substantive one-liner about what shipped]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- [Files with descriptions]

## Decisions Made
- [Any runtime decisions]

## Issues Encountered
- [Problems and resolutions]

## Next Phase Readiness
- Phase 4: Code Quality complete
- Ready for Phase 5: Design System
</output>
