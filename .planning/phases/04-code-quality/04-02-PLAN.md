---
phase: 04-code-quality
plan: 02
type: execute
---

<objective>
Modularize the backend server.js (1622 lines) into routes, services, and middleware modules.

Purpose: Improve maintainability and testability by separating concerns.
Output: server.js reduced to <200 lines, with logic distributed to focused modules.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan context:
@.planning/phases/04-code-quality/04-01-SUMMARY.md

# Key files:
@translation-backend/server.js
@translation-backend/utils/validation.js

**Tech stack available:** express, express-rate-limit, pg, @xenova/transformers, vitest
**Established patterns:** Validation middleware from 04-01

**Current server.js structure (from symbols):**
- Routes: /analyze, /define, /define-batch, /deck/*, /questions/*, /health, /languages, /stats
- Services: Claude API calls, database queries, embeddings
- Middleware: CORS, rate limiting, validation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract route handlers into separate files</name>
  <files>translation-backend/routes/analyze.js, translation-backend/routes/define.js, translation-backend/routes/deck.js, translation-backend/routes/questions.js, translation-backend/routes/health.js</files>
  <action>
Create routes directory and extract route handlers:

1. routes/analyze.js - POST /analyze handler
   - Export: router with /analyze endpoint
   - Import: services/claude.js, services/embeddings.js, services/database.js

2. routes/define.js - POST /define, POST /define-batch handlers
   - Export: router with both endpoints
   - Import: services/claude.js, services/dictionary.js

3. routes/deck.js - GET /deck/:userId, POST /deck/add, DELETE /deck/:cardId, GET /deck/:userId/export
   - Export: router with all deck endpoints
   - Import: services/database.js

4. routes/questions.js - POST /questions/generate, GET /questions/deck/:userId, etc.
   - Export: router with all question endpoints
   - Import: services/claude.js, services/database.js

5. routes/health.js - GET /health, GET /stats, GET /languages
   - Export: router with utility endpoints

Each route file:
- Uses express.Router()
- Exports the router
- Has focused responsibility

Do NOT change any business logic - pure extraction.
  </action>
  <verify>All route files created, can be imported without errors</verify>
  <done>5 route files exist with extracted handlers</done>
</task>

<task type="auto">
  <name>Task 2: Extract services</name>
  <files>translation-backend/services/claude.js, translation-backend/services/database.js, translation-backend/services/embeddings.js, translation-backend/services/dictionary.js</files>
  <action>
Create services directory and extract business logic:

1. services/claude.js - Claude API interactions
   - Export: getClaudeAnalysis(text, language), getClaudeDefinition(word, sentence, language), generateQuestions(text, language)
   - Handle API key, prompts, error handling
   - This is where duplicated Claude call patterns get consolidated

2. services/database.js - PostgreSQL operations
   - Export: pool (connection pool), findSimilarArticles(), saveAnalysis(), getDeck(), addToDecK(), etc.
   - Import: pg Pool

3. services/embeddings.js - ML embedding operations
   - Export: generateEmbedding(text), initEmbedder()
   - Import: @xenova/transformers
   - Handle lazy initialization

4. services/dictionary.js - Dictionary lookup
   - Export: lookupDictionary(word, language)
   - French dictionary optimization logic

Pattern: Each service exports pure functions or clearly named methods.
Services should not import routes - dependency flows one way.
  </action>
  <verify>All service files created, can be imported without errors</verify>
  <done>4 service files exist with extracted logic</done>
</task>

<task type="auto">
  <name>Task 3: Extract middleware and wire up server.js</name>
  <files>translation-backend/middleware/cors.js, translation-backend/middleware/rateLimit.js, translation-backend/middleware/apiKey.js, translation-backend/server.js</files>
  <action>
1. Create middleware directory:

middleware/cors.js:
- Export: corsMiddleware (configured CORS handler)
- Export: isOriginAllowed(origin)
- Include ALLOWED_ORIGINS constant

middleware/rateLimit.js:
- Export: limiter (rate limit middleware)
- Include configuration constants

middleware/apiKey.js:
- Export: requireValidApiKey middleware
- Export: validateApiKey() function
- Export: apiKeyValid state getter

2. Update server.js to be thin orchestration:
```javascript
const express = require('express');
const { corsMiddleware } = require('./middleware/cors');
const { limiter } = require('./middleware/rateLimit');
const { validateApiKey } = require('./middleware/apiKey');

const analyzeRoutes = require('./routes/analyze');
const defineRoutes = require('./routes/define');
const deckRoutes = require('./routes/deck');
const questionsRoutes = require('./routes/questions');
const healthRoutes = require('./routes/health');

const app = express();

// Middleware
app.use(corsMiddleware);
app.use(express.json({ limit: '10mb' }));
app.use(limiter);

// Routes
app.use(analyzeRoutes);
app.use(defineRoutes);
app.use(deckRoutes);
app.use(questionsRoutes);
app.use(healthRoutes);

// Startup
validateApiKey();
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
```

Target: server.js under 50 lines.
  </action>
  <verify>npm start works, npm test passes, curl /health returns 200</verify>
  <done>server.js is <50 lines, all routes work via curl tests</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm start` works without errors
- [ ] `npm test` passes
- [ ] `curl localhost:3001/health` returns 200
- [ ] `curl localhost:3001/languages` returns language list
- [ ] server.js is under 100 lines
- [ ] No console errors on startup
</verification>

<success_criteria>
- server.js reduced from 1622 lines to <100 lines
- 5 route files with focused responsibilities
- 4 service files with extracted business logic
- 3 middleware files
- All existing functionality preserved
- Tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-code-quality/04-02-SUMMARY.md`:

# Phase 4 Plan 02: Backend Modularization Summary

**[Substantive one-liner about what shipped]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- [Files with descriptions]

## Decisions Made
- [Any runtime decisions]

## Issues Encountered
- [Problems and resolutions]

## Next Step
- Ready for 04-03: Extension Modularization
</output>
